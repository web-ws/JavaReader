# RabbitMQ
# Kafka
# RocketMQ

```
RocketMQ：
    组成：生产者群/消费者群/名称服务器（存储每个Broker的主题，消息队列）/消息服务器
    构建机制：
        生产者群从名称服务器中获取主题的路由信息
        消费服务器与名称服务器保持心跳连接（10s一次，断开2分钟，认为你以死亡）
    生产消息：
        消息结构：
            基础属性：
                topic:主题相当于消息的一级分类，比方说一个电商系统可以分为商品消息、订单消息、物流消息等，就可以在broker中创建商品主题、订单主题等
                消息体：即消息的内容 ，可以的字符串、对象等类型（可系列化）。消息的最大长度 是4M
                消息 Flag：消息的一个标记，RocketMQ不处理，留给业务系统使用
            扩展属性：
                tag ：相当于消息的二级分类，用于消费消息时进行过滤，可为空 。
        消息发送方式：
            同步消息：producer向 broker 发送消息，执行 API 时同步等待， 直到broker 服务器返回发送结果。
            异步消息：producer向 broker 发送消息时指定消息发送成功及发送异常的回调方法，调用 API 后立即返回，producer发送消
                 息线程不阻塞 ，消息发送成功或失败的回调任务在一个新的线程中执行 。
            单向消息：producer向 broker 发送消息，执行 API 时直接返回，不等待broker 服务器的结果 。
        消息格式：对象转json，json转对象
    消费模式：
        集群模式：
            主题下的消息只被消费者组中的一个消费者消费
        广播模式：
            主题下的消息能被消费者组中的所有消费者消费
            消费者与broker之间通过推模式（broker推给消费者）和拉模式（消费者主动从broker获取）接收消息
    延迟消息：
        延迟消息也叫做定时消息，比如在电商项目的交易系统中，当用户下单之后超过一段时间之后仍然没有支付，此时
        就需要将该订单关闭。要实现该功能的话，可以在用户创建订单时，就发送一条包含订单内容的延迟消息，该消息在
        一段时间之后投递给消息消费者，当消息消费者接收到该消息后，判断该订单的支付状态，如果处于未支付状态，
        则将该订单关闭。
        RocketMQ的延迟消息实现非常简单，只需要发送消息前设置延迟的时间，延迟时间存在十八个等级
        （1s/5s/10s/30s/1m/2m/3m/4m/5m/6m/7m/8m/9m/10m/20m/30m/1h/2h），调用setDelayTimeLevel()设置
        与时间相对应的延迟级别即可。
    消息重试
        定义：消费者在消费消息成功会向broker返回成功状态，否则会不断进行消费重试
        当消息发送到Broker成功，在被消费者消费时如果消费者没有正常消费，此时消息会重试消费。消费重试存在两种场景：
            1）网络异常：消息没有被消费者接收，比如消费者与broker存在网络异常。此种情况消息会一直被消费重试。
            2）消费异常：当消息已经被消费者成功接收，但是在进行消息处理时出现异常，消费端无法向Broker返回成功，这种情况下RocketMQ会不断重试。
        针对第二种消费重试的场景，borker是怎么知道重试呢？
            消息会按照延迟消息的延迟时间等级（1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h）从第3级开始重试，每试一次如果还不成功则延迟等级加1。
            当重试了16次还未被成功消费将会投递到死信队列，到达死信队列的消息将不再被消费。
        实际生产中的处理策略是什么呢？
            实际生产中不会让消息重试这么多次，通常在重试一定的次数后将消息写入数据库，由另外单独的程序或人工去处理。
        int reconsumeTimes = messageExt.getReconsumeTimes();
```
